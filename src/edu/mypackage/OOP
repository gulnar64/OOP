OOP
	Naming Conventions in Java
		Class - noun
		interface - adjective -  Try to use ‘able’ at the end
		Methods - verb of oe word,  multi-word, that begins with a verb in lowercase followed by an adjective, noun…
		Variable
			Common names for temporary variables are i, j, k, m, and n for integers; c, d, and e for characters
		Packages
			The prefix of a unique package name is always written in all-lowercase ASCII letters and should be one of the top-level domain names, like com, edu, gov, mil, net, org.
			Subsequent components of the package name vary according to an organization’s own internal naming conventions.
		Do look out for these exceptions cases to camel casing in java as follows:
			In package, everything is small even while we are combining two or more words in java
			In constants, we do use everything as uppercase and only ‘_’ character is used even if we are combining two or more words in java.
	Access Modifiers
		types
			public
			protected
			private
			default
		Important Points
			If other programmers use your class, try to use the most restrictive access level that makes sense for a particular member. Use private unless you have a good reason not to.
			Avoid public fields except for constants.
	OOPS concepts are as follows:
		1. Class
			What is class
			declarations
				1. Modifiers
				2. Class keyword
				3. Class name
				4. Superclass
				5. Interfaces
				6. Body
			Properties
			1. Class is not a real-world entity. It is just a template or blueprint or prototype from which objects are created.
			2. Class does not occupy memory.
			3. Class is a group of variables of different data types and a group of methods.
			4. A Class in Java can contain:
				Data member
				Method
				Constructor
				Nested Class
				Interface
			declarations components
			There are various types of classes that are used in real-time applications such as nested classes, anonymous classes, and lambda expressions.
		2. Object
			When an object of a class is created, the class is said to be instantiated
			we can’t create objects of an abstract class or an interface.
			initiliaze object
				1. with new keyword
				2. by using method/function
				3. Test obj = (Test)Class.forName("com.p1.Test").newInstance();
				4. clone method
					ClassName obj2 = (ClassName)obj1.clone();
					* we need implements Cloneable and override clone method
						class ClassName implements Cloneable {
						@Override
						protected Object clone() throws CloneNotSupportedException {
							return super.clone();
						}
				5. Deserialization
					De-serialization is a technique of reading an object from the saved state in a file.
					FileInputStream file = new FileInputStream(filename);
					ObjectInputStream in = new ObjectInputStream(file);
					Object obj = in.readObject();
			consists of :
				1. State: It is represented by the attributes of an object. It also reflects the properties of an object.
				2. Behavior: It is represented by the methods of an object. It also reflects the response of an object to other objects.
				3. Identity: It is a unique name given to an object that enables it to interact with other objects.
			The objects that are not referenced anymore will be destroyed by the Garbage Collector of Java.
			In the inheritance system, we use a parent class reference variable to store a sub-class object. 	ParentClass obj = new SubClass()
			difference object & class
				Class is the blueprint of an object. It is used to create objects.	An object is an instance of the class.
				A classNo memory is allocated when a class is declared.	An object Memory is allocated as soon as an object is created.
				A class is a group of similar objects.	An object is a real-world entity such as a book, car, etc.
				Class is a logical entity.	An object is a physical entity.
				A class can only be declared once.	Objects can be created many times as per requirement.
		3. Method and method passing
			Advantage of Method
				Code Reusability
				Code Optimization
			method components
				1. access modifier (Optional)
				2. return type (Mandatory)
				3. method name (Mandatory)
				4. parameter list (Optional)
				5. exception list (Optional)
				6. method body (Optional)
			Types
				1. Predefined Method - standard library method or built-in method
				2. User-defined Method
			Create ways
				1. Instance Method
				2. Static Method
			Method Signature
				It consists of the method name and a parameter list (number of parameters, type of the parameters, and order of the parameters). The return type and exceptions are not considered as part of it.
			There can be three situations when a method is called
				It completes all the statements in the method
				It reaches a return statement
				Throws an exception
			several advantages
				Reusability
				Abstraction
				Improved readability
				Encapsulation
				Separation of concerns
				Improved modularity
				Improved testability
				Improved performance
			Methods calls are implemented through a stack.
	Constructors
		special method that is used to initialize objects
		default contructor (call super())
		Different From Java Methods
			Constructors must have the same name as the class within which it is defined it is not necessary for the method in Java.
			Constructors do not return any type while method(s) have the return type or void if does not return any value.
			Constructors are called only once at the time of Object creation while method(s) can be called any number of times.
		The first line of a constructor is a call to super() or this(), (a call to a constructor of a super-class or an overloaded constructor), if you don’t type in the call to super in your constructor the compiler will provide you with a non-argument call to super at the first line of your code, the super constructor must be called to create an object
		Rules for writing constructors
			The constructor(s) of a class must have the same name as the class name in which it resides.
			A constructor in Java can not be abstract, final, static, or Synchronized.
			Access modifiers can be used in constructor declaration to control its access i.e which other class can call the constructor.
		Types
			Default Constructor - Default constructor provides the default values to the object like 0, null, etc. depending on the type.
			Parameterized Constructor
			Copy Constructor
				Unlike other constructors copy constructor is passed with another object which copies the data available from the passed object to the newly created object.
				In Java,there is no such inbuilt copy constructor available like in other programming languages such as C++, instead we can create our own copy constructor by passing the object of the same class to the other instance(object) of the class.
				Geek(Geek obj2){
					this.name = obj2.name;
				}
		constructor can be declared private. A private constructor is used in restricting object creation.

		OOP
        	Pure(Complete, Fully) Object Oriented Language
        		Java isn't Pure Object Oriented Language. it isn't support 5&7 rules
        		There are seven qualities to be satisfied for a programming language to be pure Object Oriented
        			1. Encapsulation/Data Hiding (data-hiding)
        				It is defined as the wrapping up of data under a single unit. It is the mechanism that binds together the code and the data it manipulates. Another way to think about encapsulation is that it is a protective shield that prevents the data from being accessed by the code outside this shield.
        				steps
        					Declare the variables as private
        					Declare the setters and getters to set and get the variable values
        				advantages
        					Data Hiding: it is a way of restricting the access of our data members by hiding the implementation details. Encapsulation also provides a way for data hiding. The user will have no idea about the inner implementation of the class. It will not be visible to the user how the class is storing values in the variables. The user will only know that we are passing the values to a setter method and variables are getting initialized with that value.
        					Increased Flexibility: We can make the variables of the class read-only or write-only depending on our requirements. If we wish to make the variables read-only then we have to omit the setter methods like setName(), setAge(), etc. from the above program or if we wish to make the variables write-only then we have to omit the get methods like getName(), getAge(), etc. from the above program
        					Reusability: Encapsulation also improves the re-usability and is easy to change with new requirements.
        					Testing code is easy: Encapsulated code is easy to test for unit testing.
        					Freedom to programmer in implementing the details of the system: This is one of the major advantage of encapsulation that it gives the programmer freedom in implementing the details of a system. The only constraint on the programmer is to maintain the abstract interface that outsiders see.
        				disadvantages
        					Can lead to increased complexity, especially if not used properly.
        					Can make it more difficult to understand how the system works.
        					May limit the flexibility of the implementation.
        			2. Inheritance (“is-a” relationship)
        				important terminologies
        					Superclass - base or parent class
        					Subclass - derived or extended or child class
        					Reusability
        				types
        					1. Single Inheritance: Class B inherits Class A using extends keyword
        					2. Multilevel Inheritance: Class C inherits class B and B inherits class A using extends keyword
        					3. Hierarchy Inheritance: Class B and C inherits class A in hierarchy order using extends keyword
        					4. Multiple Inheritance (Through Interfaces): Class C inherits Class A and B. Here A and B both are superclass and C is only one child class. Java is not supporting Multiple Inheritance, but we can implement using Interfaces.
        					5. Hybrid Inheritance: It is a mix of two or more of the above types of inheritance.
        				instanceof
        				What Can Be Done in a Subclass?
        					The inherited fields can be used directly, just like any other fields.
        					We can declare new fields in the subclass that are not in the superclass.
        					The inherited methods can be used directly as they are.
        					We can write a new instance method in the subclass that has the same signature as the one in the superclass, thus overriding it (as in the example above, toString() method is overridden).
        					We can write a new static method in the subclass that has the same signature as the one in the superclass, thus hiding it.
        					We can declare new methods in the subclass that are not in the superclass.
        					We can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword super.
        				Advantages Of Inheritance in Java:
        					Code Reusability: Inheritance allows for code reuse and reduces the amount of code that needs to be written. The subclass can reuse the properties and methods of the superclass, reducing duplication of code.
        					Abstraction: Inheritance allows for the creation of abstract classes that define a common interface for a group of related classes. This promotes abstraction and encapsulation, making the code easier to maintain and extend.
        					Class Hierarchy: Inheritance allows for the creation of a class hierarchy, which can be used to model real-world objects and their relationships.
        					Polymorphism: Inheritance allows for polymorphism, which is the ability of an object to take on multiple forms. Subclasses can override the methods of the superclass, which allows them to change their behavior in different ways.
        				Disadvantages of Inheritance in Java:
        					Complexity: Inheritance can make the code more complex and harder to understand. This is especially true if the inheritance hierarchy is deep or if multiple inheritances is used.
        					Tight Coupling: Inheritance creates a tight coupling between the superclass and subclass, making it difficult to make changes to the superclass without affecting the subclass.
        				important points
        					 Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.
        			3. Polymorphism
        				It refers to the ability of object-oriented programming languages to differentiate between entities with the same name efficiently.
        				Polymorphism is the ability to perform many things in many ways. The word Polymorphism is from two different Greek words- poly and morphs. “Poly” means many, and “Morphs” means forms. So polymorphism means many forms. The polymorphism can be present in the case of inheritance also. The functions behave differently based on the actual implementation.
        				Polymorphism allows us to perform a single action in different ways. In other words, polymorphism allows you to define one interface and have multiple implementations.
        				types
        					Static or Compile-time Polymorphism - method overloading
        						subtype
        							function overloading
        							operator overloading - But Java doesn’t support the Operator Overloading. It is a feature in C++ where the operators such as +, -, *, etc. can be given additional meanings when applied to user-defined data types.
        							Template - it is a powerful feature in C++ that allows us to write generic functions and classes. A template is a blueprint for creating a family of functions or classes.
        					Dynamic or Run-time Polymorphism - method overriding
        						Subtype
        							Virtual functions - It allows an object of a derived class to behave as if it were an object of the base class. The derived class can override the virtual function of the base class to provide its own implementation. The function call is resolved at runtime, depending on the actual type of the object.
        				Advantages
        					Increases code reusability by allowing objects of different classes to be treated as objects of a common class.
        					Improves readability and maintainability of code by reducing the amount of code that needs to be written and maintained.
        					Supports dynamic binding, enabling the correct method to be called at runtime, based on the actual class of the object.
        					Enables objects to be treated as a single type, making it easier to write generic code that can handle objects of different types.
        				Disadvantages
        					Can make it more difficult to understand the behavior of an object, especially if the code is complex.
        					This may lead to performance issues, as polymorphic behavior may require additional computations at runtime.
        			4. Abstraction
        				Data Abstraction is the property by virtue of which only the essential details are displayed to the user. The trivial or non-essential units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.
        				two ways to achieve abstraction
        					Abstract class (0 to 100%)
        					Interface (100%)
        				The abstract method (subclasser responsibility) contains only method declaration but not implementation.
        				In abstraction, we deal with ideas and not events. This means the user will only know “what it does” rather than “how it does”
        				abstract keyword
        					abstract is a non-access modifier in java applicable for classes, and methods but not variables.
        					Advantages
        						Provides a way to define a common interface: Abstract classes can define a common interface that can be used by all subclasses. By defining common methods and properties, abstract classes provide a way to enforce consistency and maintainability across an application.
        						Enables polymorphism: By defining a superclass as abstract, you can create a collection of subclasses that can be treated as instances of the superclass. This allows for greater flexibility and extensibility in your code, as you can add new subclasses without changing the code that uses them.
        						Encourages code reuse: Abstract classes can define common methods and properties that can be reused by all subclasses. This saves time and reduces code duplication, which can make your code more efficient and easier to maintain.
        						Provides a way to enforce implementation: Abstract methods must be implemented by any concrete subclass of the abstract class. This ensures that certain functionality is implemented consistently across all subclasses, which can prevent errors and improve code quality.
        						Enables late binding: By defining a common interface in an abstract class, you can use late binding to determine which subclass to use at runtime. This allows for greater flexibility and adaptability in your code, as you can change the behavior of your program without changing the code itself.
        				key points
        					An abstract class may or may not have all abstract methods. Some of them can be concrete methods
        					There can be no object of an abstract class. That is, an abstract class can not be directly instantiated with the new operator. Although abstract classes cannot be used to instantiate objects, they can be used to create object references, because Java’s approach to run-time polymorphism is implemented through the use of super-class references.
        					The class should be abstract if a class has one or many abstract methods
        					An abstract class can have constructors, concrete methods, static method, and final method
        					The child class should override all the abstract methods of parent else the child class should be declared with abstract keyword
        					Abstract classes can have constructors: Abstract classes can have constructors, which are used to initialize instance variables and perform other initialization tasks. However, because abstract classes cannot be instantiated directly, their constructors are typically called constructors in concrete subclasses.
        					Abstract classes can contain instance variables: Abstract classes can contain instance variables, which can be used by both the abstract class and its subclasses. Subclasses can access these variables directly, just like any other instance variables.
        					Abstract classes can implement interfaces: Abstract classes can implement interfaces, which define a set of methods that must be implemented by any class that implements the interface. In this case, the abstract class must provide concrete implementations of all methods defined in the interface.
        					There can be a final method in abstract class but any abstract method in class(abstract class) can not be declared as final  or in simpler terms final method can not be abstract itself as it will yield an error: “Illegal combination of modifiers: abstract and final”
        				Elements abstract class
        					data member
        					abstract method
        					method body (non-abstract method)
        					constructor
        					main() method.
        				The following are various illegal combinations of other modifiers for methods with respect to abstract modifiers:
        					final
        					abstract native
        					abstract synchronized
        					abstract static
        					abstract private
        					abstract strictfp
        				An abstract class is faster than an interface because the interface involves a search before calling any overridden method in Java whereas abstract class can be directly used.
        				Advantages
        					It reduces the complexity of viewing things.
        					Avoids code duplication and increases reusability.
        					Helps to increase the security of an application or program as only essential details are provided to the user.
        					It improves the maintainability of the application.
        					It improves the modularity of the application.
        					The enhancement will become very easy because without affecting end-users we can able to perform any type of changes in our internal system.
        					Improves code reusability and maintainability.
        					Hides implementation details and exposes only relevant information.
        					Provides a clear and simple interface to the user.
        					Increases security by preventing access to internal class details.
        					Supports modularity, as complex systems can be divided into smaller and more manageable parts.
        					Abstraction provides a way to hide the complexity of implementation details from the user, making it easier to understand and use.
        					Abstraction allows for flexibility in the implementation of a program, as changes to the underlying implementation details can be made without affecting the user-facing interface.
        					Abstraction enables modularity and separation of concerns, making code more maintainable and easier to debug.
        				Disadvantages
        					Abstraction can make it more difficult to understand how the system works.
        					It can lead to increased complexity, especially if not used properly.
        					This may limit the flexibility of the implementation.
        					Abstraction can add unnecessary complexity to code if not used appropriately, leading to increased development time and effort.
        					Abstraction can make it harder to debug and understand code, particularly for those unfamiliar with the abstraction layers and implementation details.
        					Overuse of abstraction can result in decreased performance due to the additional layers of code and indirection.
        				Difference between Encapsulation and Data Abstraction
        					Encapsulation is data hiding(information hiding)	Abstraction is detailed hiding(implementation hiding).
        					Encapsulation groups together data and methods that act upon the data	Data Abstraction deal with exposing the interface to the user and hiding the details of implementation
        					Encapsulated classes are Java classes that follow data hiding and abstraction	Implementation of abstraction is done using abstract classes and interface
        					Encapsulation is a procedure that takes place at the implementation level	abstraction is a design-level process
        				Difference between Abstract Classes and Interface
        					Abstract classes support abstract and Non-abstract methods	Interface supports have abstract methods only.
        					Doesn’t support Multiple Inheritance	Supports Multiple Inheritance
        					Abstract classes can be extended by Java classes and multiple interfaces	The interface can be extended by Java interface only.
        					Abstract class members in Java can be private, protected, etc.	Interfaces are public by default.
        			5. All predefined types are objects
        			6. All user defined types are objects
        			7. All operations performed on objects must be only through methods exposed at the objects.
        	Interface
        		An Interface in Java programming language is defined as an abstract type used to specify the behavior of a class. An interface in Java is a blueprint of a behavior.
        		A Java interface public, contains static constants and abstract methods and  and all fields are public, static, and final by default
        		Java Interface also represents the IS-A relationship
        		abstract classes may contain non-final variables, whereas variables in the interface are final, public, and static.
        		It is used to achieve abstraction
        		By interface, we can support the functionailty of multiple inheritance
        		It can be used to achieve loose coupling
        		class extends class, interface extends interface, class implemenet interface but vice-versa is not allowed
        		Difference Between Class and Interface
        			In class, you can instantiate variables and create an object.	In an interface, you can’t instantiate variables and create an object.
        			A class can contain concrete(with implementation) methods	The interface cannot contain concrete(with implementation) methods
        			The access specifiers used with classes are private, protected, and public.	In Interface only one specifier is used- Public.
        		Advantages
        			Without bothering about the implementation part, we can achieve the security of the implementation.
        			In Java, multiple inheritances are not allowed, however, you can use an interface to make use of it as you can implement more than one interface.
        		JDK 8 update
        			We can now add default implementation for interface methods.
        			we can now define static methods in interfaces that can be called independently without an object.
        		JDK 9 update
        			Static methods
        			Private methods
        			Private Static methods
        		If the implementation is unable to provide an implementation of all abstract methods, then declare the implementation class with an abstract modifier, and complete the remaining method implementation in the next created child classes.
        		the development process is step by step
        			1. Level 1-  interfaces: It contains the service details.
        			2. Level 2 – abstract classes: It contains partial implementation.
        			3. Level 3 – implementation classes: It contains all implementation.
        			4. Level 4 – Final Code / Main Method: It have access of all interfaces data.
        		Important Points
        			Inside the Interface not possible to declare instance variables because by default variables are public static final.
        			Inside the Interface, constructors are not allowed.
        			Inside the interface main method is not allowed.
        			Inside the interface, static, final, and private methods declaration are not possible.
        		Tagged Interfaces are interfaces without any methods they serve as a marker without any capabilities.
        		Types
        			Functional Interface
        			Marker interface
        	this reference
        		‘this’ is a reference variable that refers to the current object
        		using
        			Using the ‘this’ keyword to refer to current class instance variables.
        			Using this() to invoke the current class constructor
        			Using ‘this’ keyword to return the current class instance
        			Using ‘this’ keyword as the method parameter
        			Using ‘this’ keyword to invoke the current class method
        			Using ‘this’ keyword as an argument in the constructor call
        		Advantages
        			It helps to distinguish between instance variables and local variables with the same name.
        			It can be used to pass the current object as an argument to another method.
        			It can be used to return the current object from a method.
        			It can be used to invoke a constructor from another overloaded constructor in the same class.
        		Disadvantages
        			Overuse of this can make the code harder to read and understand.
        			Using this unnecessarily can add unnecessary overhead to the program.
        			Using this in a static context results in a compile-time error.
        			Overall, this keyword is a useful tool for working with objects in Java, but it should be used judiciously and only when necessary.
        	keywords
        		The keywords const and goto are reserved, even they are not currently in use.
        		true, false and null look like keywords, but in actual they are literals. However they still can’t be used as identifiers in a program.
        		strictfp: It is used for restricting floating-point calculations and ensuring the same result on every platform while performing operations in the floating-point variable. For more refer strictfp keyword in Java
        		synchronized: Applicable for blocks methods. It is used to get synchronization in java. For more, refer to Synchronized in Java
        		transient
        			transient is a variables modifier used in serialization. At the time of serialization, if we don’t want to save the value of a particular variable in a file, then we use the transient keyword. For more refer transient keyword in Java
        			When JVM comes across transient keyword, it ignores original value of the variable and save default value of that variable data type
        			transient and static : Since static fields are not part of state of the object, there is no use/impact of using transient keyword with static variables. However there is no compilation error.
        			transient and final : final variables are directly serialized by their values, so there is no use/impact of declaring final variable as transient. There is no compile-time error though.
        		volatile: The volatile modifier tells the compiler that the variable modified by volatile can be changed unexpectedly by other parts of your program. For more, refer to volatile keyword in java
        		super:
        			rules:
        				super must be the first statement in a constructor
        				super cannot be used in a static context
        				super is not required to call a superclass method:
        			use of
        				Use of super with Variables
        				Use of super with Methods
        				Use of super with Constructors
        			Advantages
        				Enables reuse of code: Using the super keyword allows subclasses to inherit functionality from their parent classes, which promotes the reuse of code and reduces duplication.
        				Supports polymorphism: Because subclasses can override methods and access fields from their parent classes using super, polymorphism is possible. This allows for more flexible and extensible code.
        				Provides access to parent class behaviour: Subclasses can access and use methods and fields defined in their parent classes through the super keyword, which allows them to take advantage of existing behaviour without having to reimplement it.
        				Allows for customization of behaviour: By overriding methods and using super to call the parent implementation, subclasses can customize and extend the behaviour of their parent classes.
        				Facilitates abstraction and encapsulation: The use of super promotes encapsulation and abstraction by allowing subclasses to focus on their behaviour while relying on the parent class to handle lower-level details
        		final
        			final is a non-access modifier
        			used
        				final variable - to create constant variable
        					A final variable is called a blank final variable if it is not initialized while declaration. two ways to initialize a blank final variable.
        						A blank final variable can be initialized inside an instance-initializer block or inside the constructor. If you have more than one constructor in your class then it must be initialized in all of them, otherwise, a compile-time error will be thrown.
        						A blank final static variable can be initialized inside a static block.
        					reference final variable, the internal state of the object pointed by that reference variable can be changed. Note that this is not re-assigning. This property of final is called non-transitivity.
        				final methods - prevent method overriding
        				final classess - prevent inheritance
        					usage
        						One is definitely to prevent inheritance, as final classes cannot be extended. For example, all Wrapper Classes like Integer, Float, etc. are final classes.
        						The other use of final with classes is to create an immutable class like the predefined String class. One can not make a class immutable without making it final.
        			Advantages
        				Ensuring immutability: When a variable or reference is marked as final, its value cannot be changed once it is assigned. This helps ensure that data is immutable and cannot be accidentally or maliciously modified.
        				Improving performance: The use of final can sometimes help improve performance, as the Java Virtual Machine (JVM) can optimize code more effectively when it knows that certain values or references cannot be changed.
        				Making code easier to understand: By declaring variables, methods, or classes as final, developers can make their code easier to understand and reason about. When a value or reference is marked as final, it is clear that it will not change, which can simplify code analysis and debugging.
        				Promoting code reuse: By declaring methods as final, developers can prevent subclasses from overriding them. This can help promote code reuse and reduce duplication, as subclasses must use the parent class’s implementation of the method.
        				Enhancing security: The use of final can help enhance security by preventing malicious code from modifying sensitive data or behavior.
        		static
        			The static keyword is a non-access modifier
        			The users can apply static keywords
        				Blocks
        				Variables
        				Methods
        					restrictions
        						They can only directly call other static methods.
        						They can only directly access static data.
        						They cannot refer to this or super in any way.
        				Classes
        					A class can be made static only if it is a nested class
        			characteristics
        				Shared memory allocation: Static variables and methods are allocated memory space only once during the execution of the program. This memory space is shared among all instances of the class, which makes static members useful for maintaining global state or shared functionality.
        				Accessible without object instantiation: Static members can be accessed without the need to create an instance of the class. This makes them useful for providing utility functions and constants that can be used across the entire program.
        				Associated with class, not objects: Static members are associated with the class, not with individual objects. This means that changes to a static member are reflected in all instances of the class, and that you can access static members using the class name rather than an object reference.
        				Cannot access non-static members: Static methods and variables cannot access non-static members of a class, as they are not associated with any particular instance of the class.
        				Can be overloaded, but not overridden: Static methods can be overloaded, which means that you can define multiple methods with the same name but different parameters. However, they cannot be overridden, as they are associated with the class rather than with a particular instance of the class.
        			Advantages
        				Memory efficiency: Static members are allocated memory only once during the execution of the program, which can result in significant memory savings for large programs.
        				Improved performance: Because static members are associated with the class rather than with individual instances, they can be accessed more quickly and efficiently than non-static members.
        				Global accessibility: Static members can be accessed from anywhere in the program, regardless of whether an instance of the class has been created.
        				Encapsulation of utility methods: Static methods can be used to encapsulate utility functions that don’t require any state information from an object. This can improve code organization and make it easier to reuse utility functions across multiple classes.
        				Constants: Static final variables can be used to define constants that are shared across the entire program.
        				Class-level functionality: Static methods can be used to define class-level functionality that doesn’t require any state information from an object, such as factory methods or helper functions.
        		Enum
        			A Java enumeration is a class type. Although we don’t need to instantiate an enum using new
        			Just like classes, you can give them constructors, add instance variables and methods, and even implement interfaces.
        			We can’t create enum objects explicitly and hence we can’t invoke the enum constructor directly
        			unlike classes, enumerations neither inherit other classes nor can get extended
        			All enums implicitly extend java.lang.Enum class. As a class can only extend one parent in Java, an enum cannot extend anything else.
        			toString() method is overridden in java.lang.Enum class, which returns enum constant name.
        			enum can implement many interfaces.
        			Enum can contain both concrete methods and abstract methods. If an enum class has an abstract method, then each instance of the enum class must implement it.
        			method
        				values()
        				valueOf()
        				ordinal()
        			Declaration
        				outside a class
        				inside a class
        			Properties
        				Every enum is internally implemented by using Class.
        				Every enum constant represents an object of type enum.
        				Enum type can be passed as an argument to switch statements.
        				Every enum constant is always implicitly public static final. Since it is static, we can access it by using the enum Name. Since it is final, we can’t create child enums.
        				We can declare the main() method inside the enum. Hence we can invoke the enum directly from the Command Prompt.
	Memory
		Management
			 major concepts in Java Memory Management :
				JVM Memory Structure
					Some of the areas are created by the JVM whereas some are created by the threads that are used in a program. However, the memory area created by JVM is destroyed only when the JVM exits. The data areas of thread are created during instantiation and destroyed when the thread exits.
					Java memory area parts / memory in the JVM is divided into 5 different parts:
						Heap
							It is a shared runtime data area and stores the actual object in a memory. It is instantiated during the virtual machine startup.
							Heap can be of fixed or dynamic size depending upon the system’s configuration.
							There exists one and only one heap for a running JVM process
						Class (Method) area
							It is a logical part of the heap area and is created on virtual machine startup.
							This memory is allocated for class structures, method data and constructor field data, and also for interfaces or special method used in class. Heap can be of fixed or dynamic size depending upon the system’s configuration.
							Can be of a fixed size or expanded as required by the computation. Needs not to be contiguous.
							Note: Though method area is logically a part of heap, it may or may not be garbage collected even if garbage collection is compulsory in heap area.
						Jvm stack
							A stack is created at the same time when a thread is created and is used to store data and partial results which will be needed while returning value for method and performing dynamic linking.
							Stacks can either be of fixed or dynamic size. The size of a stack can be chosen independently when it is created.
							The memory for stack needs not to be contiguous.
						Native method stack
							Also called as C stacks, native method stacks are not written in Java language. This memory is allocated for each thread when its created. And it can be of fixed or dynamic nature.
						Ps registers
							Each JVM thread which carries out the task of a specific method has a program counter register associated with it. The non native method has a PC which stores the address of the available JVM instruction whereas in a native method, the value of program counter is undefined. PC register is capable of storing the return address or a native pointer on some specific platform.
		Garbage collector
			JVM triggers this process and as per the JVM garbage collection process is done or else withheld. It reduces the burden of programmer by automatically performing the allocation or deallocation of memory.
			Garbage collection process causes the rest of the processes or threads to be paused and thus is costly in nature. This problem is unacceptable for the client but can be eliminated by applying several garbage collector based algorithms. This process of applying algorithm is often termed as Garbage Collector tuning and is important for improving the performance of a program.
			Another solution is the generational garbage collectors that adds an age field to the objects that are assigned a memory. As more and more objects are created, the list of garbage grows thereby increasing the garbage collection time. On the basis of how many clock cycles the objects have survived, objects are grouped and are allocated an ‘age’ accordingly. This way the garbage collection work gets distributed.
			In the current scenario, all garbage collectors are generational, and hence, optimal.
			The main objective of Garbage Collector is to free heap memory by destroying unreachable objects.
			The garbage collector is the best example of the Daemon thread as it is always running in the background.
			The garbage collection implementation lives in the JVM
			Eligibility for garbage collection: An object is said to be eligible for GC(garbage collection) if it is unreachable.
			four ways to make an object eligible
				Nullifying the reference variable
				Re-assigning the reference variable
				An object created inside the method
				Island of Isolation
			two Ways for requesting JVM to run Garbage Collector
				Using System.gc() method: System class contain static method gc() for requesting JVM to run Garbage Collector.
				Using Runtime.getRuntime().gc() method: Runtime class allows the application to interface with the JVM in which the application is running.
				key points
					There is no guarantee that any of the above two methods will run Garbage Collector.
					The call System.gc() is effectively equivalent to the call : Runtime.getRuntime().gc()
			Types of Activities
				Minor or incremental Garbage Collection: It is said to have occurred when unreachable objects in the young generation heap memory are removed.
				Major or Full Garbage Collection: It is said to have occurred when the objects that survived the minor garbage collection are copied into the old generation or permanent generation heap memory are removed. When compared to the young generation, garbage collection happens less frequently in the old generation.
			Finalization
				Just before destroying an object, Garbage Collector calls finalize() method on the object to perform cleanup activities. Once finalize() method completes, Garbage Collector destroys that object.
				finalize() method is present in Object class: protected void finalize() throws Throwable
				Based on our requirement, we can override finalize() method for performing our cleanup activities like closing connection from the database.
					The finalize() method is called by Garbage Collector, not JVM. However, Garbage Collector is one of the modules of JVM.
					Object class finalize() method has an empty implementation. Thus, it is recommended to override the finalize() method to dispose of system resources or perform other cleanups.
					The finalize() method is never invoked more than once for any object.
					If an uncaught exception is thrown by the finalize() method, the exception is ignored, and the finalization of that object terminates.
				Example
			garbage collector use Mark and Sweep algorithm to clear unused memory.
			Each garbage collector will vary in Application throughput and Application pause
			types
				Serial Garbage Collector
					This is the simplest GC implementation, as it basically works with a single thread.t freezes all other running threads of application until garbage collection operations have concluded.
					Implementation
					java -XX:+UseSerialGC -jar GFGApplicationJar.java
				Parallel Garbage Collector
					Parallel Garbage Collector is the default garbage collector in Java 8. It is also known as Throughput collector. Parallel Garbage Collector also freezes the running threads of the application while performing the garbage collection. But the difference is, Parallel Garbage Collector uses multiple threads to perform cleaning of unused heap area.
					Implementation
						java -XX:+UseParallelGC -jar GFGApplicationJar.java
					The advantage of using Garbage Collector as default GC is we can mention few attributes
						How many threads
							Implementation
								java -XX:+UseParallelGC -XX:ParallelGCThreads=NumberOfThreads -jar GFGApplicationJar.java
						Maximum pause
							Implementation
								java -XX:+UseParallelGC -XX:MaxGCPauseMillis=SecInMillisecond -jar GFGApplicationJar.java
				CMS Garbage collector
					CMS Garbage collector is known as concurrent mark-sweep garbage collector. This garbage collector uses multiple threads to scan the heap memory consistently to the mark objects that are unused and then sweep the marked objects.
					CMS Garbage collector will perform freezing of running threads i.e. application pause in two cases only:
						While performing the garbage collection, If there is a change in heap memory in parallel.
						While marking the referenced objects in the old generation space.
					If we compare CMS collector with Parallel garbage collector, CMS collector uses more CPU to ensure better application throughput.
					Implementation
						java -XX:+UseParNewGC -jar GFGApplicationJar.java
				G1 Garbage Collector
					Firstly G1 Garbage Collector is introduced in JDK 7. Initially, It was designed to provide better support for larger heap memory application. G1 Garbage Collector is the default garbage collection of Java 9. G1 collector replaced the CMS collector since it’s more performance efficient. How G1 Garbage Collector works is different from other collectors. Unlike other collectors, the G1 collector partitions the heap space into multiple equal-sized regions. Basically it is mainly designed for an application having heap size greater than 4GB. It divides the heap area into multiple regions vary from 1MB to 32MB. While performing the garbage collection, G1 Garbage Collector mark the heap region which has objects that are in use throughout the heap. By the help of this garbage collector has the information about the regions that contains most use less objects and garbage collector first perform the garbage collection on that region only. Thats why it is known as G first garbage collector. G1 also does compact the free heap space just after garbage collection that makes G1 Garbage Collector better than other garbage collectors. G1 Garbage Collector is the default garbage collector of Java 9.
					Implementation
						java -XX:+UseG1GC -jar GFGApplicationJar.java
		 stored in memory
			 when we allocate the object using new(), the object is allocated on Heap, otherwise on Stack if not global or static.
			 two ways to create an object  of string in java:
				By string literal
				By new keyword
			Stack Allocation
				The allocation happens on contiguous blocks of memory. We call it a stack memory allocation because the allocation happens in the function call stack. The size of memory to be allocated is known to the compiler and whenever a function is called, its variables get memory allocated on the stack. And whenever the function call is over, the memory for the variables is de-allocated.
				Each thread has a private JVM stack, created at the same time as the thread.
				Java Stack stores frames
				This kind of memory allocation is also known as Temporary memory allocation because as soon as the method finishes its execution all the data belonging to that method flushes out from the stack automatically. This means any value stored in the stack memory scheme is accessible as long as the method hasn’t completed its execution and is currently in a running state.
				We receive the corresponding error Java. lang. StackOverFlowError by JVM, If the stack memory is filled completely.
				Stack memory allocation is considered safer as compared to heap memory allocation because the data stored can only be accessed by the owner thread.
				Memory allocation and de-allocation are faster as compared to Heap-memory allocation.
				Stack memory has less storage space as compared to Heap-memory.
				For every thread, JVM creates a separate stack at the time of thread creation. The memory for a Java Virtual Machine stack does not need to be contiguous. The Java virtual machine only performs two operations directly on Java stacks: it pushes and pops frames. And stack for a particular thread may be termed as Run – Time Stack.
				After completing all method calls the stack becomes empty and that empty stack is destroyed by the JVM just before terminating the thread.
				The data stored in the stack is available for the corresponding thread and not available to the remaining threads. Hence we can say local data thread-safe. Each entry in the stack is called Stack Frame or Activation Record.
				Stack Frame
					parts
						Local Variable Array (LVA)
							The local variables part of the stack frame is organized as a zero-based array of words.
							It contains all parameters and local variables of the method.
							Each slot or entry in the array is of 4 Bytes.
							Values of type int, float, and reference occupy 1 entry or slot in the array i.e. 4 bytes.
							Values of double and long occupy 2 consecutive entries in the array i.e. 8 bytes total.
							Byte, short, and char values will be converted to int type before storing and occupy 1 slot i.e. 4 Bytes.
							But the way of storing Boolean values is varied from JVM to JVM. But most of the JVM gives 1 slot for Boolean values in the local variable array.
							The parameters are placed into the local variable array first, in the order in which they are declared.
						Operand Stack (OS):
							JVM uses operand stack as workspace like rough work or we can say for storing intermediate calculation’s result.
							The operand stack is organized as an array of words like a local variable array. But this is not accessed by using an index like local variable array rather it is accessed by some instructions that can push the value to the operand stack and some instructions that can pop values from the operand stack and some instructions that can perform required operations.
							Example
						Frame Data (FD):
							It contains all symbolic references (constant pool resolution) and normal method returns related to that particular method.
							It also contains a reference to the Exception table which provides the corresponding catch block information in the case of exceptions.
			Heap Allocation
				If a programmer does not handle this memory well, a memory leak can happen in the program.
				Memory leaks
					creates lots of objects and does not use them.
					Such types of useless objects are called as Memory leaks. If allocated memory goes beyond limit, program will be terminated by rising OutOfMemoryError.
					use some tools that do memory management to identifies useless objects or memory leaks like
						HP OVO
						HP J METER
						JProbe
						IBM Tivoli
				three categories
					Young Generation – It’s the portion of the memory where all the new data(objects) are made to allocate the space and whenever this memory is completely filled then the rest of the data is stored in Garbage collection.
					Old or Tenured Generation – This is the part of Heap-memory that contains the older data objects that are not in frequent use or not in use at all are placed.
					Permanent Generation – This is the portion of Heap-memory that contains the JVM’s metadata for the runtime classes and application methods.
				We receive the corresponding error message if Heap-space is entirely full,  java. lang.OutOfMemoryError by JVM.
				This memory allocation scheme is different from the Stack-space allocation, here no automatic de-allocation feature is provided. We need to use a Garbage collector to remove the old unused objects in order to use the memory efficiently.
				Heap memory is accessible or exists as long as the whole application(or java program) runs.
			Between Stack and Heap Allocations
				In a stack, the allocation and de-allocation are automatically done by the compiler whereas, in heap, it needs to be done by the programmer manually.
				Handling the Heap frame is costlier than handling the stack frame.
				Memory shortage problem is more likely to happen in stack whereas the main issue in heap memory is fragmentation.
				Stack frame access is easier than the heap frame as the stack has a small region of memory and is cache-friendly but in the case of heap frames which are dispersed throughout the memory so it causes more cache misses.
				A stack is not flexible, the memory size allotted cannot be changed whereas a heap is flexible, and the allotted memory can be altered.
				Accessing the time of heap takes is more than a stack
				Parameter						STACK														HEAP
				Basic							Memory is allocated in a contiguous block.					Memory is allocated in any random order.
				Allocation and De-allocation	Automatic by compiler instructions.							Manual by the programmer.
				Cost							Less														More
				Implementation					Easy														Hard
				Access time						Faster														Slower
				Main Issue						Shortage of memory											Memory fragmentation
				Locality of reference			Excellent													Adequate
				Safety							Thread safe, data stored can only be accessed by the owner	Not Thread safe, data stored visible to all threads
				Flexibility						Fixed-size													Resizing is possible
				Data type structure				Linear														Hierarchical
				Preferred						Static memory allocation is preferred in an array.			Heap memory allocation is preferred in the linked list.
				Size							Small than heap memory.										Larger than stack memory.
		JVM
			JVM (Java Virtual Machine) is an abstract machine, In other words, it is a program/software which takes Java bytecode and converts the byte code (line by line) into machine understandable code.
			JVM(Java Virtual Machine) acts as a run-time engine to run Java applications. JVM is the one that actually calls the main method present in Java code
			types of operations:
				Loading of code
				Verification of code
				Executing the code
				It provides a run-time environment to the users
			ClassLoader
				It is a subsystem of JVM which is used to load class files. It is mainly responsible for three activities.
					Loading
					Linking
					Initialization